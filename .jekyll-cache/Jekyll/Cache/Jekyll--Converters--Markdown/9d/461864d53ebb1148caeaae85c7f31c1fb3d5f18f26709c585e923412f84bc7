I"<h3 id="84-寻址方式2">8.4 寻址方式(2)</h3>

<p>寻址方式的小结表格:</p>

<table>
  <thead>
    <tr>
      <th>寻址方式</th>
      <th>含义</th>
      <th>名称</th>
      <th>常用格式举例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[idata]</td>
      <td>EA=idata;SA=(ds)</td>
      <td>直接寻址</td>
      <td>[idata]</td>
    </tr>
    <tr>
      <td>[bx]</td>
      <td>EA=(bx);SA=(ds)</td>
      <td>寄存器间接寻址</td>
      <td>[bx]</td>
    </tr>
    <tr>
      <td>[si]</td>
      <td>EA=(bx);SA=(ds)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>[di]</td>
      <td>EA=(di);SA=(ds)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>[bp]</td>
      <td>EA=(bp);SA=(ss)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>[bx+idata]</td>
      <td>EA=(bx)+idata;SA=(ds)</td>
      <td>寄存器相对寻址</td>
      <td>用于结构体: [bx].idata</td>
    </tr>
    <tr>
      <td>[si+idata]</td>
      <td>EA=(si)+idata;SA=(ds)</td>
      <td> </td>
      <td>用于数组: idata[si],idata[di]</td>
    </tr>
    <tr>
      <td>[di+idata]</td>
      <td>EA=(di)+idata;SA=(ds)</td>
      <td> </td>
      <td>用于二位数组: [bx][idata]</td>
    </tr>
    <tr>
      <td>[bp+idata]</td>
      <td>EA=(bp)+idata;SA=(ss)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>[bx+si]</td>
      <td>EA=(bx)+(si);SA=(ds)</td>
      <td>基址变址寻址</td>
      <td>用于二维数组: [bx][si]</td>
    </tr>
    <tr>
      <td>[bx+di]</td>
      <td>EA=(bx)+(di);SA=(ds)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>[bp+si]</td>
      <td>EA=(bp)+(si);SA=(ss)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>[bp+di]</td>
      <td>EA=(bp)+(di);SA=(ss)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>[bx+si+idata]</td>
      <td>EA=(bx)+(si)+idata;SA=(ds)</td>
      <td>相对基址变址寻址</td>
      <td>用于表格(结构)中的数组项:</td>
    </tr>
    <tr>
      <td>[bx+di+idata]</td>
      <td>EA=(bx)+(di)+idata;SA=(ds)</td>
      <td> </td>
      <td>[bx].idata[si]</td>
    </tr>
    <tr>
      <td>[bp+si+idata]</td>
      <td>EA=(bp)+(si)+idata;SA=(ss)</td>
      <td> </td>
      <td>用于二维数组:</td>
    </tr>
    <tr>
      <td>[bp+di+idata]</td>
      <td>EA=(bp)+(di)+idata;SA=(ss)</td>
      <td> </td>
      <td>idata[bx][si]</td>
    </tr>
  </tbody>
</table>

<p>我们以相对基址变址寻址为例，用图例讲一下寻址和运行的步骤：</p>

<p>首先代码段地址和偏移地址在地址加法器合成20位地址数据:
<img src="/assets/201911/2019-11-20_15-55-41.png" alt="figure1" />
20位地址20018随着地址总线传输到内存，寻找对应地址的代码地址8B4001，并沿数据总线传输到指令缓冲寄存器。
<img src="/assets/201911/2019-11-20_15-55-47.png" alt="figure2" />
<img src="/assets/201911/2019-11-20_15-55-57.png" alt="figure3" />
之后CPU会从对应的指令缓冲寄存器中的指令，将对应在ds, si, bx中的地址在地址加法器中进行处理变为20012，再沿地址总线寻找对应地址的数据8B07(低位在前，高位在后)。之后8B07将会沿着数据总线进入ax中。
<img src="/assets/201911/2019-11-20_15-56-11.png" alt="figure4" />
<img src="/assets/201911/2019-11-20_15-56-20.png" alt="figure5" />
<img src="/assets/201911/2019-11-20_15-56-33.png" alt="figure6" /></p>

<h3 id="85-指令要处理的数据有多长">8.5 指令要处理的数据有多长</h3>

<p>8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作。对于这个问题，汇编语言中用一下方法处理。</p>

<p>(1) 通过寄存器名指明要处理的数据的尺寸。</p>

<p>寄存器指明了指令进行的是字(字型)操作。</p>

<pre><code class="language-x86asm">mov ax, 1
mov bx, ds:[0] ;这里的ds:[0]传入了bx中，为字型数据
      ;所以这里的ds:[0]应该包含ds:[1](前8位高位地址)
      ;ds:[0]包含低位的后8位数据
mov ds, ax
mov ds:[0], ax
inc ax
add ax, 1000
</code></pre>
<p>而对于字节型的操作。</p>

<pre><code class="language-x86asm">mov al, 1    ;字节型
mov al, bl
mov al, ds:[0]
mov ds:[0], al
inc al
add al, 100
</code></pre>

<p>(2) 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X 为word 或者byte。例如：</p>

<pre><code class="language-x86asm">;字型
mov word ptr ds:[0], 1
inc word ptr [bx]
inc word ptr ds:[0]
add word ptr [bx], 2
;字节
mov byte ptr ds:[0], 1
inc byte ptr [bx]
inc byte ptr ds:[0]
add byte ptr [bx], 2
</code></pre>
<p>如果没有指明数据类型，很容易造成溢出错误，例如’FFH’ + ‘1’ = ‘00H’，而16位的数据’00FFH’ + 1 = ‘0100H’。</p>

<p>再如，</p>

<p>2000: 1000 FF FF FF FF FF FF</p>

<p>指令，</p>

<pre><code class="language-x86asm">mov ax, 2000H
mov ds, ax
mov byte ptr [1000H], 1
</code></pre>

<p>将使内存中的内容变为,</p>

<p>2000: 1000 01 FF FF FF FF FF</p>

<p>而如果指令为，</p>

<pre><code class="language-x86asm">mov ax, 2000H
mov ds, ax
mov word ptr [1000H], 1
</code></pre>

<p>将使内存中的内容变为，</p>

<p>2000: 1000 01 00 FF FF FF FF</p>

<p>因为对于字节型和字型数据，所针对的数据长度是不同的。同样也强调了明确数据类型的必要性!</p>

<p>(3) 其他方法</p>

<p>有些指令默认了访问的是字单元还是字节单元，如栈指令，<code class="language-plaintext highlighter-rouge">push</code>，只针对字单元进行操作(对于<code class="language-plaintext highlighter-rouge">push</code>，sp=sp-2)。</p>

:ET