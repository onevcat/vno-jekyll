---
layout: post
title: 汇编语言3.1 3.2 3.3
date: 2019-10-02 14:39:24.000000000 +09:00
---
第二章中，主要讲CPU如何执行指令的角度讲解了8086的逻辑结构、形成物理地址的方法、相关的寄存器以及一些指令。这一章将从访问内存的角度继续学习几个寄存器。

### 3.1 内存中字的存储

| 0 | 20H |
| 1 | 4EH |
| 2 | 12H |
| 3 | 00H |
| 4 |     |
| 4 |     |

本例中，我们用0、1两个内存单元存放数据20000(4E20H)。其中0位为地地址单元，1号为高地址单元，同理在2、3号单元中存放数据18（0012H)。

> 子单元的概念，即存放一个**字形数据**（16位）的内存单元，由两个地址连续的内存单元组成。高低地址内存单元分别存放字型数据的高低字节。

> 注意这里引入的几个概念：

1. 字节单元，字节型数据。我们一般所指的地址单元，如0地址单元所指的就是字节单元，所以在例子中的0地址单元中存放的字节型数据为20，一个内存地址存放的就是一个字节。
2. 字单元，字型数据。这里的字单元与字型数据值得为一个字，均考虑两个字节。而当提及字型数据时，记住要将数据延伸到其对应高位，如本例中1地址单元中存放的字型数据为124EH。

### 3.2 DS和[address]

下面代码来实现读取10000H单元的内容：

```assembly
mov bx, 1000H
mov ds, bx
mov al, [0]
```

> 这里有两点需要注意：

1. 8086CPU**不支持将数据直接送入段寄存器的操作，ds是一个段寄存器**，所以```mov ds, 1000H```这两条指令是非法的。
2. 8086CPU自动取ds中的数据为内存单元的段地址。
3. 第三行中[...]表示一个内存单元，```[...]```中的0表示内存单元的**偏离地址**。
4. 也可以将通用寄存器存储到偏移地址中，命令为```mov [0], al```

总结：

> 数据 ---> 通用寄存器 ---> 段寄存器

### 3.3 字的传送

前面我们用mov指令在寄存器和内存之间进行字节型的传送。因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是说可以一次性传送**一个字**。只要在mov指令中给出16位的寄存器就可以进行16位的数据传送。

```assembly
mov bx, 1000H
mov ds, bx
mov ax, [0]
mov [0], cx
```

> 代码中有几个需要注意的地方：

1. 第三行中如果给出的不是ax而是al，则存入的是8位的数据
2. 第三行，1000:0处的字型数据送入ax, 字型数据为16位的，高位为10001，低位为10000，因为内存单元中只能存放8位数据
