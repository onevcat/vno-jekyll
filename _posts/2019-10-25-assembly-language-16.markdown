---
layout: post
title: 汇编语言 5.2 loop
date: 2019-10-25 17:07:24.000000000 +09:00
---

### Loop 指令

loop 指令的格式是：loop 标号， CPU执行loop指令的时候，要进行两步操作：

1. $(CX) = (CX) - 1$
2. 判断CX的值，不为零则转至标号处执行程序，如果为零则继续向下执行

> CX的值影响着loop指令的执行结果。通常，我们用loop指令来实现循环功能，CX中存放着循环的次数

我们编写一个实现$2^12$的代码，代码如下：

```x86asm
assume cs:code
code segment
start: mov ax, 2

       mov cx, 11
    s: add ax, ax
       loop s

       mov ax, 4c00H ; 注意这里必须写H，因为编译里默认10进制而非16进制
       int 21H

code ends
end start
```
这里有三个注意事项：

1. 标号，代表一个地址，可以替换为其他名称。这个地址里标识了一个地址，这个地址有一条指令：```add ax, ax```
2. loop s, 执行时要执行两步操作：1. $(CX) = (CX) - 1$ 2. 判断CX中的值，不为零跳转到标号s所标识的地址处执行，如果为零则跳转到后面代码
3. 执行下面指令：
```x86asm
    mov cx, 11
s:  add ax, ax
    loop s
```
执行loop s时，首先将(CX)减一，然后若(CX)不为0，则向前转至s处执行add ax, ax。可以利用(CX)来控制循环数。

下面我们进行编译并尝试debug跟踪：

![figure1](/assets/201910/2019-10-25_17-36-19.png)

这里```CX = 000F```初始标识的这个程序的大小为15个字节。

随后，我们开始执行循环命令，如下图

![figure2](/assets/201910/2019-10-25_17-53-04.png)

这里观察代码段的偏移地址，代码会反复循环在```IP=0006```, 这是循环开始的标号。

直到循环结束计算出$AX=2^{12}=1000H$(十六进制)。

![figure3](/assets/201910/2019-10-25_17-58-08.png)
