---
layout: post
title: 汇编语言 5.3 Debug跟踪loop循环
date: 2019-10-26 12:31:24.000000000 +09:00
tags: 汇编语言
---

### 5.3 在Debug中跟踪用loop指令实现的循环程序

首先要考虑一下超出地址存储能力的问题：

加入我们要计算在FFFF:0006单元中的数乘以3，并将结果存储在DX中。

> 我们每次做这种类似的计算时，要注意是否会超出DX的存储范围！

ffff:0006单元中的数是**字节型**数据，所以范围在0~255之间，这是因为对于字节型数据，计算方式如下：

$$2^8=256$$

所以范围在0~255之间，相对的对于DX通用寄存器，由于数据存储针对的往往是**字型数据**，而针对于16位的字型数据，计算方式如下：

$$2^{16}=65536$$

所以数据长度在0~65535之间，所以在FFFF:0006中的8位字节型数据乘以3是不会超过DX寄存器的存储长度的。

但是要注意的是，每次执行类似loop循环指令时，都要考虑到数据存储是否会超过相应寄存器的存储长度。

> 循环累加来实现乘法，如何使用寄存器

将FFFF:0006单元中的数值赋值给AX，用DX进行累加。先设$(DX)=0$，再做3次$(DX)=(DX)+(AX)$运算。

> 如何保证字节单元和寄存器字型数据的长度统一并赋值？

设FFFF:6单元中的数据时XXH，若要AX中的值和FFFF:0006单元中的相等，AX中的数据应为00XXH。所以，若实现FFFF:0006单元向AX赋值，应该令$(AH)=0$，$(AL)=(FFFF6H)$。

书中给出代码：

```x86asm
assume cs:code
code segment
    mov ax, 0ffffh ;注意这里
    mov ds, ax
    mov bx, 6
    
    mov al, [bx]
    mov ah, 0   ;这行以及下一行可以简写为
    mov dx, 0   ;mov ax, [bx]
    
    mov cx, 3
s:  add dx, ax
    loop s
    
    mov ax, 4c00h
    int 21h

code ends
end
```

> 注意代码第三行，汇编源程序中，不能以字母开头，所以必须加0!!

#### 关于多次循环的debug跟踪

之前涉及到的代码都是循环次数较少的跟踪过程，那么假如循环次数很多，又该如何解决呢？

这里有两个方案：

第一个方案是遇到循环指令时后，直接输入```-p```命令，自动重复执行，直到$(CX)=0$为止。

第二个方案是在遇到，如```loop 0012```时，直接用，如```g 0016```直接执```CS:0016```处，进而跳过循环。



